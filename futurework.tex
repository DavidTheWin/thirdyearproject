\chapter{Future Work} \label{futurework}
The core implementation of \textit{qbftoepr} is complete in that it can take in a QDIMACS input and produce a TPTP output. Nonetheless there are still areas where optimizations can be made. This chapter will discuss three optimizations that were not implemented due to time constraints.

\section{Dependency Scheme Optimizations}
The construction of dependency schemes was discussed in section~\ref{devdepscheme}. The current implementation of the standard dependency scheme iterates over the matrix to find variables in the same clauses as a given existential variable but section~\ref{stddepscheme} showed that the tractable algorithm for finding the standard dependency scheme uses a bipartite graph.

\subsection{Tractable Standard Dependency Scheme} \label{tractablestddepscheme}
As seen in section~\ref{trivialvsstd} the standard dependency scheme produces TPTP outputs that are significantly smaller than the results from the trivial dependency scheme but the former takes much more time to execute. This is due to the iterative implementation of the standard dependency scheme (the complexity of which was discussed in section~\ref{depschemecomplexity}). Changing this implementation to build the incidence graph of the formula as in figure~\ref{bigrapheasy} then perform the linear search described in section~\ref{stddepscheme} would fix the problem with the current implementation described in section~\ref{devdepscheme} and would make the dependency scheme tractable and potentially return a significant saving in execution time.

\subsection{Triangle Dependency Scheme}
Samer and Szeider~\cite{samer2009backdoor} detailed one more dependency scheme in their paper called the triangle dependency scheme that will only be summarised here. It is constructed in a similar way to the standard dependency scheme by creating a graph of literals and the clauses they are in. However it is not a bipartite graph this time because literals are also connected to their negation. The dependencies are paths between a variable $x$ and $y$ that avoid its negation $\neg x$ and paths between its negation $\neg x$ and $y$ that avoid $x$ while only using clauses with variables in the set $R(x)$ (as in \ref{stddepscheme}) but not including $y$. This scheme is also tractable by finding paths in the graph between the two literals and further reduces the number of dependencies of a variable.

\section{Anti-prenexing}
Section~\ref{qbf} discussed prenexing where a series of rewrite rules are performed on a formula to bring the quantifiers to the front of the formula to form a prefix. This prenexing process is not deterministic though. A different choice of rewrite rules could lead to a different order of quantifiers in the prefix which could in turn lead to fewer dependencies if existential variables are moved further up the prefix. Anti-prenexing is the process of applying the rewrite rules in reverse to backtrack to a choice of rewrite rules to try another choice in the hope that it gives a better prenexing.

Section~\ref{datastructures} discussed the \texttt{qbf} and \texttt{fol\_qbf} data structures. It is hard to implement anti-prenexing on these data structures as the \texttt{clause} type only allows for \texttt{literal}s so introducing \texttt{quantified\_variable}s via anti-prenexing (which would split the prefix and add quantifiers into the clauses) is not possible. These data structures were designed with the QDIMACS input format in mind which is already prenexed so anti-prenexing was not anticipated. This makes them very fit-to-purpose and they dispose of the generalities of the construction of \glspl{qbf} that would allow quantified variables inside the formula rather than only in a prefix. A more tree like structure with sub-formulas as nodes would permit anti-prenexing.

An implementation of anti-prenexing alone is not enough though. Once the rewriting rules can be applied in reverse they must be applied in the right way so as to be advantageous whereas it is possible to arrive back at the same prenexing or potentially even a worse prenexing. Therefore heuristics are required to determine which rules to use in which order to aim for an advantageous prenexing.
